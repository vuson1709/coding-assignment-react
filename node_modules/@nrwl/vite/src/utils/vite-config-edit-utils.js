"use strict";
Object.defineProperty(exports, "ensureBuildOptionsInViteConfig", {
    enumerable: true,
    get: ()=>ensureBuildOptionsInViteConfig
});
const _devkit = require("@nrwl/devkit");
const _typescript = require("nx/src/utils/typescript");
const _tsquery = require("@phenomnomnominal/tsquery");
const ts = require("typescript");
function ensureBuildOptionsInViteConfig(tree, path, buildConfigString, buildConfigObject, dtsPlugin, dtsImportLine, pluginOption, testConfigString, testConfigObject, projectAlreadyHasViteTargets) {
    const fileContent = tree.read(path, 'utf-8');
    let updatedContent = undefined;
    if (!(projectAlreadyHasViteTargets == null ? void 0 : projectAlreadyHasViteTargets.test) && (testConfigString == null ? void 0 : testConfigString.length)) {
        updatedContent = handleBuildOrTestNode(fileContent, testConfigString, testConfigObject, 'test');
    }
    if (!(projectAlreadyHasViteTargets == null ? void 0 : projectAlreadyHasViteTargets.build) && (buildConfigString == null ? void 0 : buildConfigString.length)) {
        updatedContent = handlePluginNode(updatedContent != null ? updatedContent : fileContent, dtsPlugin, dtsImportLine, pluginOption);
        updatedContent = handleBuildOrTestNode(updatedContent != null ? updatedContent : fileContent, buildConfigString, buildConfigObject, 'build');
    }
    if (updatedContent) {
        tree.write(path, updatedContent);
        return true;
    } else {
        return false;
    }
}
function handleBuildOrTestNode(updatedFileContent, configContentString, configContentObject, name) {
    const buildNode = _tsquery.tsquery.query(updatedFileContent, `PropertyAssignment:has(Identifier[name="${name}"])`);
    if (buildNode.length) {
        return _tsquery.tsquery.replace(updatedFileContent, `PropertyAssignment:has(Identifier[name="${name}"])`, (node)=>{
            const found = _tsquery.tsquery.query(node, 'ObjectLiteralExpression');
            return `${name}: {
                  ...${found == null ? void 0 : found[0].getText()},
                  ...${JSON.stringify(configContentObject)}
               }`;
        });
    } else {
        const foundDefineConfig = _tsquery.tsquery.query(updatedFileContent, 'CallExpression:has(Identifier[name="defineConfig"])');
        if (foundDefineConfig.length) {
            const conditionalConfig = _tsquery.tsquery.query(foundDefineConfig[0], 'ArrowFunction');
            if (conditionalConfig.length) {
                if (name === 'build') {
                    return transformConditionalConfig(conditionalConfig, updatedFileContent, configContentString);
                } else {
                    // no test config in conditional config
                    return undefined;
                }
            } else {
                const propertyAssignments = _tsquery.tsquery.query(foundDefineConfig[0], 'PropertyAssignment');
                if (propertyAssignments.length) {
                    return (0, _devkit.applyChangesToString)(updatedFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: propertyAssignments[0].getStart(),
                            text: configContentString
                        }
                    ]);
                } else {
                    return (0, _devkit.applyChangesToString)(updatedFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: foundDefineConfig[0].getStart() + 14,
                            text: configContentString
                        }
                    ]);
                }
            }
        } else {
            // build config does not exist and defineConfig is not used
            // could also potentially be invalid syntax, so try-catch
            try {
                const defaultExport = _tsquery.tsquery.query(updatedFileContent, 'ExportAssignment');
                const found = _tsquery.tsquery == null ? void 0 : _tsquery.tsquery.query(defaultExport == null ? void 0 : defaultExport[0], 'ObjectLiteralExpression');
                const startOfObject = found == null ? void 0 : found[0].getStart();
                return (0, _devkit.applyChangesToString)(updatedFileContent, [
                    {
                        type: _devkit.ChangeType.Insert,
                        index: startOfObject + 1,
                        text: configContentString
                    }
                ]);
            } catch (e) {
                return undefined;
            }
        }
    }
}
function transformCurrentBuildObject(index, returnStatements, appFileContent, buildConfigObject) {
    var ref;
    if (!(returnStatements == null ? void 0 : returnStatements[index])) {
        return undefined;
    }
    const currentBuildObject = (ref = _tsquery.tsquery.query(returnStatements[index], 'ObjectLiteralExpression')) == null ? void 0 : ref[0].getText();
    const currentBuildObjectStart = returnStatements[index].getStart();
    const currentBuildObjectEnd = returnStatements[index].getEnd();
    const newReturnObject = _tsquery.tsquery.replace(returnStatements[index].getText(), 'ObjectLiteralExpression', (_node)=>{
        return `{
        ...${currentBuildObject},
        ...${JSON.stringify(buildConfigObject)}
     }`;
    });
    const newContents = (0, _devkit.applyChangesToString)(appFileContent, [
        {
            type: _devkit.ChangeType.Delete,
            start: currentBuildObjectStart,
            length: currentBuildObjectEnd - currentBuildObjectStart
        },
        {
            type: _devkit.ChangeType.Insert,
            index: currentBuildObjectStart,
            text: newReturnObject
        }
    ]);
    return newContents;
}
function transformConditionalConfig(conditionalConfig, appFileContent, buildConfigObject) {
    const functionBlock = _tsquery.tsquery.query(conditionalConfig[0], 'Block');
    const ifStatement = _tsquery.tsquery.query(functionBlock == null ? void 0 : functionBlock[0], 'IfStatement');
    const binaryExpressions = _tsquery.tsquery.query(ifStatement == null ? void 0 : ifStatement[0], 'BinaryExpression');
    const buildExists = binaryExpressions == null ? void 0 : binaryExpressions.find((binaryExpression)=>binaryExpression.getText() === `command === 'build'`);
    const buildExistsExpressionIndex = binaryExpressions == null ? void 0 : binaryExpressions.findIndex((binaryExpression)=>binaryExpression.getText() === `command === 'build'`);
    const serveExists = binaryExpressions == null ? void 0 : binaryExpressions.find((binaryExpression)=>binaryExpression.getText() === `command === 'serve'`);
    const elseKeywordExists = (0, _typescript.findNodes)(ifStatement == null ? void 0 : ifStatement[0], ts.SyntaxKind.ElseKeyword);
    const returnStatements = _tsquery.tsquery.query(ifStatement[0], 'ReturnStatement');
    if (!buildExists) {
        if (serveExists && elseKeywordExists) {
            // build options live inside the else block
            return transformCurrentBuildObject((returnStatements == null ? void 0 : returnStatements.length) - 1, returnStatements, appFileContent, buildConfigObject);
        } else {
            // no build options exist yet
            const functionBlockStart = functionBlock == null ? void 0 : functionBlock[0].getStart();
            const newContents = (0, _devkit.applyChangesToString)(appFileContent, [
                {
                    type: _devkit.ChangeType.Insert,
                    index: functionBlockStart + 1,
                    text: `
            if (command === 'build') {
              return ${JSON.stringify(buildConfigObject)}
            }
            `
                }
            ]);
            return newContents;
        }
    } else {
        // build already exists
        // it will be the return statement which lives
        // at the buildExistsExpressionIndex
        return transformCurrentBuildObject(buildExistsExpressionIndex, returnStatements, appFileContent, buildConfigObject);
    }
}
function handlePluginNode(appFileContent, dtsPlugin, dtsImportLine, pluginOption) {
    const file = _tsquery.tsquery.ast(appFileContent);
    const pluginsNode = _tsquery.tsquery.query(file, 'PropertyAssignment:has(Identifier[name="plugins"])');
    let writeFile = false;
    if (pluginsNode.length) {
        appFileContent = _tsquery.tsquery.replace(file.getText(), 'PropertyAssignment:has(Identifier[name="plugins"])', (node)=>{
            const found = _tsquery.tsquery.query(node, 'ArrayLiteralExpression');
            return `plugins: [
                    ...${found == null ? void 0 : found[0].getText()},
                    ${dtsPlugin}
                ]`;
        });
        writeFile = true;
    } else {
        // Plugins node does not exist yet
        // So make one from scratch
        const foundDefineConfig = _tsquery.tsquery.query(file, 'CallExpression:has(Identifier[name="defineConfig"])');
        if (foundDefineConfig.length) {
            const conditionalConfig = _tsquery.tsquery.query(foundDefineConfig[0], 'ArrowFunction');
            if (conditionalConfig.length) {
                // We are NOT transforming the conditional config
                // with plugins
                writeFile = false;
            } else {
                const propertyAssignments = _tsquery.tsquery.query(foundDefineConfig[0], 'PropertyAssignment');
                if (propertyAssignments.length) {
                    appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: propertyAssignments[0].getStart(),
                            text: pluginOption
                        }
                    ]);
                    writeFile = true;
                } else {
                    appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: foundDefineConfig[0].getStart() + 14,
                            text: pluginOption
                        }
                    ]);
                    writeFile = true;
                }
            }
        } else {
            // Plugins option does not exist and defineConfig is not used
            // could also potentially be invalid syntax, so try-catch
            try {
                const defaultExport = _tsquery.tsquery.query(file, 'ExportAssignment');
                const found = _tsquery.tsquery == null ? void 0 : _tsquery.tsquery.query(defaultExport == null ? void 0 : defaultExport[0], 'ObjectLiteralExpression');
                const startOfObject = found == null ? void 0 : found[0].getStart();
                appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                    {
                        type: _devkit.ChangeType.Insert,
                        index: startOfObject + 1,
                        text: pluginOption
                    }
                ]);
                writeFile = true;
            } catch (e) {
                writeFile = false;
            }
        }
    }
    if (writeFile) {
        if (!appFileContent.includes(`import dts from 'vite-plugin-dts'`)) {
            return dtsImportLine + '\n' + appFileContent;
        }
        return appFileContent;
    }
    return undefined;
}

//# sourceMappingURL=vite-config-edit-utils.js.map