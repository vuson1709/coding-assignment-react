"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    findExistingTargetsInProject: ()=>findExistingTargetsInProject,
    addOrChangeTestTarget: ()=>addOrChangeTestTarget,
    addOrChangeBuildTarget: ()=>addOrChangeBuildTarget,
    addOrChangeServeTarget: ()=>addOrChangeServeTarget,
    editTsConfig: ()=>editTsConfig,
    moveAndEditIndexHtml: ()=>moveAndEditIndexHtml,
    createOrEditViteConfig: ()=>createOrEditViteConfig,
    normalizeViteConfigFilePathWithTree: ()=>normalizeViteConfigFilePathWithTree,
    getViteConfigPathForProject: ()=>getViteConfigPathForProject,
    handleUnsupportedUserProvidedTargets: ()=>handleUnsupportedUserProvidedTargets,
    handleUnknownExecutors: ()=>handleUnknownExecutors
});
const _extends = require("@swc/helpers/lib/_extends.js").default;
const _devkit = require("@nrwl/devkit");
const _viteConfigEditUtils = require("./vite-config-edit-utils");
function findExistingTargetsInProject(targets, userProvidedTargets) {
    let validFoundBuildTarget, validFoundServeTarget, validFoundTestTarget, projectContainsUnsupportedExecutor, unsupportedUserProvidedTargetBuild, unsupportedUserProvidedTargetServe, unsupportedUserProvidedTargetTest, alreadyHasNxViteTargetBuild, alreadyHasNxViteTargetServe, alreadyHasNxViteTargetTest;
    const arrayOfSupportedBuilders = [
        '@nxext/vite:build',
        '@nrwl/js:babel',
        '@nrwl/js:swc',
        '@nrwl/webpack:webpack',
        '@nrwl/rollup:rollup',
        '@nrwl/web:rollup'
    ];
    const arrayOfSupportedServers = [
        '@nxext/vite:dev',
        '@nrwl/webpack:dev-server'
    ];
    const arrayOfSupportedTesters = [
        '@nrwl/jest:jest',
        '@nxext/vitest:vitest'
    ];
    const arrayofUnsupportedExecutors = [
        '@nrwl/angular:ng-packagr-lite',
        '@nrwl/angular:package',
        '@nrwl/angular:webpack-browser',
        '@angular-devkit/build-angular:browser',
        '@angular-devkit/build-angular:dev-server',
        '@nrwl/esbuild:esbuild',
        '@nrwl/react-native:run-ios',
        '@nrwl/react-native:start',
        '@nrwl/react-native:run-android',
        '@nrwl/react-native:bundle',
        '@nrwl/react-native:build-android',
        '@nrwl/react-native:bundle',
        '@nrwl/next:build',
        '@nrwl/next:server',
        '@nrwl/js:tsc'
    ];
    const arrayOfNxViteExecutors = [
        '@nrwl/vite:build',
        '@nrwl/vite:dev-server',
        '@nrwl/vite:test'
    ];
    // First, we check if the user has provided a target
    // If they have, we check if the executor the target is using is supported
    // If it's not supported, then we set the unsupported flag to true for that target
    if (userProvidedTargets == null ? void 0 : userProvidedTargets.build) {
        var ref;
        if (arrayOfSupportedBuilders.includes((ref = targets[userProvidedTargets.build]) == null ? void 0 : ref.executor)) {
            validFoundBuildTarget = userProvidedTargets.build;
        } else {
            unsupportedUserProvidedTargetBuild = true;
        }
    }
    if (userProvidedTargets == null ? void 0 : userProvidedTargets.serve) {
        var ref1;
        if (arrayOfSupportedServers.includes((ref1 = targets[userProvidedTargets.serve]) == null ? void 0 : ref1.executor)) {
            validFoundServeTarget = userProvidedTargets.serve;
        } else {
            unsupportedUserProvidedTargetServe = true;
        }
    }
    if (userProvidedTargets == null ? void 0 : userProvidedTargets.test) {
        var ref2;
        if (arrayOfSupportedServers.includes((ref2 = targets[userProvidedTargets.test]) == null ? void 0 : ref2.executor)) {
            validFoundTestTarget = userProvidedTargets.test;
        } else {
            unsupportedUserProvidedTargetTest = true;
        }
    }
    // Then, we try to find the targets that are using the supported executors
    // for build, serve and test, since these are the ones we will be converting
    for(const target in targets){
        // If we have a value for each one of the targets, we can break out of the loop
        if (validFoundBuildTarget && validFoundServeTarget && validFoundTestTarget) {
            break;
        }
        if (targets[target].executor === '@nrwl/vite:build') {
            alreadyHasNxViteTargetBuild = true;
        }
        if (targets[target].executor === '@nrwl/vite:dev-server') {
            alreadyHasNxViteTargetServe = true;
        }
        if (targets[target].executor === '@nrwl/vite:test') {
            alreadyHasNxViteTargetTest = true;
        }
        if (!validFoundBuildTarget && arrayOfSupportedBuilders.includes(targets[target].executor)) {
            validFoundBuildTarget = target;
        }
        if (!validFoundServeTarget && arrayOfSupportedServers.includes(targets[target].executor)) {
            validFoundServeTarget = target;
        }
        if (!validFoundTestTarget && arrayOfSupportedTesters.includes(targets[target].executor)) {
            validFoundTestTarget = target;
        }
        if (!arrayOfNxViteExecutors.includes(targets[target].executor) && arrayofUnsupportedExecutors.includes(targets[target].executor)) {
            projectContainsUnsupportedExecutor = true;
        }
    }
    return {
        validFoundTargetName: {
            build: validFoundBuildTarget,
            serve: validFoundServeTarget,
            test: validFoundTestTarget
        },
        projectContainsUnsupportedExecutor,
        userProvidedTargetIsUnsupported: {
            build: unsupportedUserProvidedTargetBuild,
            serve: unsupportedUserProvidedTargetServe,
            test: unsupportedUserProvidedTargetTest
        },
        alreadyHasNxViteTargets: {
            build: alreadyHasNxViteTargetBuild,
            serve: alreadyHasNxViteTargetServe,
            test: alreadyHasNxViteTargetTest
        }
    };
}
function addOrChangeTestTarget(tree, options, target) {
    var ref;
    const project = (0, _devkit.readProjectConfiguration)(tree, options.project);
    const coveragePath = (0, _devkit.joinPathFragments)('coverage', project.root === '.' ? options.project : project.root);
    const testOptions = {
        passWithNoTests: true,
        // vitest runs in the project root so we have to offset to the workspaceRoot
        reportsDirectory: (0, _devkit.joinPathFragments)((0, _devkit.offsetFromRoot)(project.root), coveragePath)
    };
    if ((ref = project.targets) == null ? void 0 : ref[target]) {
        var ref1;
        project.targets[target].executor = '@nrwl/vite:test';
        (ref1 = project.targets[target].options) == null ? void 0 : delete ref1.jestConfig;
    } else {
        if (!project.targets) {
            project.targets = {};
        }
        project.targets[target] = {
            executor: '@nrwl/vite:test',
            outputs: [
                coveragePath
            ],
            options: testOptions
        };
    }
    (0, _devkit.updateProjectConfiguration)(tree, options.project, project);
}
function addOrChangeBuildTarget(tree, options, target) {
    var ref;
    const project = (0, _devkit.readProjectConfiguration)(tree, options.project);
    const buildOptions = {
        outputPath: (0, _devkit.joinPathFragments)('dist', project.root != '.' ? project.root : options.project)
    };
    if ((ref = project.targets) == null ? void 0 : ref[target]) {
        var ref1;
        buildOptions.fileReplacements = (ref1 = project.targets[target].options) == null ? void 0 : ref1.fileReplacements;
        if (project.targets[target].executor === '@nxext/vite:build') {
            var ref2, ref3;
            buildOptions.base = (ref2 = project.targets[target].options) == null ? void 0 : ref2.baseHref;
            buildOptions.sourcemap = (ref3 = project.targets[target].options) == null ? void 0 : ref3.sourcemaps;
        }
        project.targets[target].options = _extends({}, buildOptions);
        project.targets[target].executor = '@nrwl/vite:build';
    } else {
        if (!project.targets) {
            project.targets = {};
        }
        project.targets[`${target}`] = {
            executor: '@nrwl/vite:build',
            outputs: [
                '{options.outputPath}'
            ],
            defaultConfiguration: 'production',
            options: buildOptions,
            configurations: {
                development: {
                    mode: 'development'
                },
                production: {
                    mode: 'production'
                }
            }
        };
    }
    (0, _devkit.updateProjectConfiguration)(tree, options.project, project);
}
function addOrChangeServeTarget(tree, options, target) {
    var ref;
    const project = (0, _devkit.readProjectConfiguration)(tree, options.project);
    const serveOptions = {
        buildTarget: `${options.project}:build`
    };
    if ((ref = project.targets) == null ? void 0 : ref[target]) {
        var ref1, ref2, ref3;
        if (target === '@nxext/vite:dev') {
            serveOptions.proxyConfig = project.targets[target].options.proxyConfig;
        }
        project.targets[target].options = _extends({}, serveOptions, {
            https: (ref1 = project.targets[target].options) == null ? void 0 : ref1.https,
            hmr: (ref2 = project.targets[target].options) == null ? void 0 : ref2.hmr,
            open: (ref3 = project.targets[target].options) == null ? void 0 : ref3.open
        });
        project.targets[target].executor = '@nrwl/vite:dev-server';
    } else {
        if (!project.targets) {
            project.targets = {};
        }
        project.targets[`${target}`] = {
            executor: '@nrwl/vite:dev-server',
            defaultConfiguration: 'development',
            options: {
                buildTarget: `${options.project}:build`
            },
            configurations: {
                development: {
                    buildTarget: `${options.project}:build:development`,
                    hmr: true
                },
                production: {
                    buildTarget: `${options.project}:build:production`,
                    hmr: false
                }
            }
        };
    }
    (0, _devkit.updateProjectConfiguration)(tree, options.project, project);
}
function editTsConfig(tree, options) {
    const projectConfig = (0, _devkit.readProjectConfiguration)(tree, options.project);
    const config = (0, _devkit.readJson)(tree, `${projectConfig.root}/tsconfig.json`);
    const commonCompilerOptions = {
        target: 'ESNext',
        useDefineForClassFields: true,
        module: 'ESNext',
        strict: true,
        moduleResolution: 'Node',
        resolveJsonModule: true,
        isolatedModules: true,
        types: [
            'vite/client'
        ],
        noEmit: true
    };
    switch(options.uiFramework){
        case 'react':
            config.compilerOptions = _extends({}, commonCompilerOptions, {
                lib: [
                    'DOM',
                    'DOM.Iterable',
                    'ESNext'
                ],
                allowJs: false,
                esModuleInterop: false,
                skipLibCheck: true,
                allowSyntheticDefaultImports: true,
                forceConsistentCasingInFileNames: true,
                jsx: 'react-jsx'
            });
            config.include = [
                ...config.include,
                'src'
            ];
            break;
        case 'none':
            config.compilerOptions = _extends({}, commonCompilerOptions, {
                lib: [
                    'ESNext',
                    'DOM'
                ],
                skipLibCheck: true,
                esModuleInterop: true,
                strict: true,
                noUnusedLocals: true,
                noUnusedParameters: true,
                noImplicitReturns: true
            });
            config.include = [
                ...config.include,
                'src'
            ];
            break;
        default:
            break;
    }
    (0, _devkit.writeJson)(tree, `${projectConfig.root}/tsconfig.json`, config);
}
function moveAndEditIndexHtml(tree, options, buildTarget) {
    var ref, ref1;
    const projectConfig = (0, _devkit.readProjectConfiguration)(tree, options.project);
    var ref2;
    let indexHtmlPath = (ref2 = (ref = projectConfig.targets[buildTarget].options) == null ? void 0 : ref.index) != null ? ref2 : `${projectConfig.root}/src/index.html`;
    var ref3;
    const mainPath = ((ref3 = (ref1 = projectConfig.targets[buildTarget].options) == null ? void 0 : ref1.main) != null ? ref3 : `${projectConfig.root}/src/main.ts${options.uiFramework === 'react' ? 'x' : ''}`).replace(projectConfig.root, '');
    if (!tree.exists(indexHtmlPath) && tree.exists(`${projectConfig.root}/index.html`)) {
        indexHtmlPath = `${projectConfig.root}/index.html`;
    }
    if (tree.exists(indexHtmlPath)) {
        const indexHtmlContent = tree.read(indexHtmlPath, 'utf8');
        if (!indexHtmlContent.includes(`<script type="module" src="${mainPath}"></script>`)) {
            tree.write(`${projectConfig.root}/index.html`, indexHtmlContent.replace('</body>', `<script type="module" src="${mainPath}"></script>
          </body>`));
            if (tree.exists(`${projectConfig.root}/src/index.html`)) tree.delete(`${projectConfig.root}/src/index.html`);
        }
    } else {
        tree.write(`${projectConfig.root}/index.html`, `<!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <link rel="icon" href="/favicon.ico" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Vite</title>
        </head>
        <body>
          <div id="root"></div>
          <script type="module" src="${mainPath}"></script>
        </body>
      </html>`);
    }
}
function createOrEditViteConfig(tree, options, onlyVitest, projectAlreadyHasViteTargets) {
    const projectConfig = (0, _devkit.readProjectConfiguration)(tree, options.project);
    const viteConfigPath = `${projectConfig.root}/vite.config.ts`;
    const buildOption = onlyVitest ? '' : options.includeLib ? `
      // Configuration for building your library.
      // See: https://vitejs.dev/guide/build.html#library-mode
      build: {
        lib: {
          // Could also be a dictionary or array of multiple entry points.
          entry: 'src/index.ts',
          name: '${options.project}',
          fileName: 'index',
          // Change this to the formats you want to support.
          // Don't forgot to update your package.json as well.
          formats: ['es', 'cjs']
        },
        rollupOptions: {
          // External packages that should not be bundled into your library.
          external: [${options.uiFramework === 'react' ? "'react', 'react-dom', 'react/jsx-runtime'" : ''}]
        }
      },` : ``;
    const dtsPlugin = onlyVitest ? '' : options.includeLib ? `dts({
      tsConfigFilePath: join(__dirname, 'tsconfig.lib.json'),
      // Faster builds by skipping tests. Set this to false to enable type checking.
      skipDiagnostics: true,
    }),` : '';
    const dtsImportLine = onlyVitest ? '' : options.includeLib ? `import dts from 'vite-plugin-dts';\nimport { join } from 'path';` : '';
    let viteConfigContent = '';
    const testOption = options.includeVitest ? `test: {
    globals: true,
    cache: {
      dir: '${(0, _devkit.offsetFromRoot)(projectConfig.root)}node_modules/.vitest'
    },
    environment: 'jsdom',
    include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    ${options.inSourceTests ? `includeSource: ['src/**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}']` : ''}
  },` : '';
    const defineOption = options.inSourceTests ? `define: {
    'import.meta.vitest': undefined
  },` : '';
    const reactPluginImportLine = options.uiFramework === 'react' ? `import react from '@vitejs/plugin-react';` : '';
    const reactPlugin = options.uiFramework === 'react' ? `react(),` : '';
    const serverOption = onlyVitest ? '' : options.includeLib ? '' : `
    server:{
      port: 4200,
      host: 'localhost',
    },`;
    const pluginOption = `
    plugins: [
      ${dtsPlugin}
      ${reactPlugin}
      viteTsConfigPaths({
        root: '${(0, _devkit.offsetFromRoot)(projectConfig.root)}',
      }),
    ],
    `;
    const workerOption = `
    // Uncomment this if you are using workers. 
    // worker: {
    //  plugins: [
    //    viteTsConfigPaths({
    //      root: '${(0, _devkit.offsetFromRoot)(projectConfig.root)}',
    //    }),
    //  ],
    // },`;
    if (tree.exists(viteConfigPath)) {
        handleViteConfigFileExists(tree, viteConfigPath, options, buildOption, dtsPlugin, dtsImportLine, pluginOption, testOption, (0, _devkit.offsetFromRoot)(projectConfig.root), projectAlreadyHasViteTargets);
        return;
    }
    viteConfigContent = `
      import { defineConfig } from 'vite';
      ${reactPluginImportLine}
      import viteTsConfigPaths from 'vite-tsconfig-paths';
      ${dtsImportLine}
      
      export default defineConfig({
        ${serverOption}
        ${pluginOption}
        ${workerOption}
        ${buildOption}
        ${defineOption}
        ${testOption}
      });`;
    tree.write(viteConfigPath, viteConfigContent);
}
function normalizeViteConfigFilePathWithTree(tree, projectRoot, configFile) {
    return configFile && tree.exists(configFile) ? configFile : tree.exists((0, _devkit.joinPathFragments)(`${projectRoot}/vite.config.ts`)) ? (0, _devkit.joinPathFragments)(`${projectRoot}/vite.config.ts`) : tree.exists((0, _devkit.joinPathFragments)(`${projectRoot}/vite.config.js`)) ? (0, _devkit.joinPathFragments)(`${projectRoot}/vite.config.js`) : undefined;
}
function getViteConfigPathForProject(tree, projectName, target) {
    let viteConfigPath;
    const { targets , root  } = (0, _devkit.readProjectConfiguration)(tree, projectName);
    if (target) {
        var ref, ref1;
        viteConfigPath = (ref = targets[target]) == null ? void 0 : (ref1 = ref.options) == null ? void 0 : ref1.configFile;
    } else {
        var ref2, ref3;
        const buildTarget = Object.entries(targets).find(([_targetName, targetConfig])=>{
            return targetConfig.executor === '@nrwl/vite:build';
        });
        viteConfigPath = buildTarget == null ? void 0 : (ref2 = buildTarget[1]) == null ? void 0 : (ref3 = ref2.options) == null ? void 0 : ref3.configFile;
    }
    return normalizeViteConfigFilePathWithTree(tree, root, viteConfigPath);
}
async function handleUnsupportedUserProvidedTargets(userProvidedTargetIsUnsupported, userProvidedTargetName, validFoundTargetName) {
    if (userProvidedTargetIsUnsupported.build && validFoundTargetName.build) {
        await handleUnsupportedUserProvidedTargetsErrors(userProvidedTargetName.build, validFoundTargetName.build, 'build', 'build');
    }
    if (userProvidedTargetIsUnsupported.serve && validFoundTargetName.serve) {
        await handleUnsupportedUserProvidedTargetsErrors(userProvidedTargetName.serve, validFoundTargetName.serve, 'serve', 'dev-server');
    }
    if (userProvidedTargetIsUnsupported.test && validFoundTargetName.test) {
        await handleUnsupportedUserProvidedTargetsErrors(userProvidedTargetName.test, validFoundTargetName.test, 'test', 'test');
    }
}
async function handleUnsupportedUserProvidedTargetsErrors(userProvidedTargetName, validFoundTargetName, action, executor) {
    _devkit.logger.warn(`The custom ${action} target you provided (${userProvidedTargetName}) cannot be converted to use the @nrwl/vite:${executor} executor.
     However, we found the following ${action} target in your project that can be converted: ${validFoundTargetName}

     Please note that converting a potentially non-compatible project to use Vite.js may result in unexpected behavior. Always commit
     your changes before converting a project to use Vite.js, and test the converted project thoroughly before deploying it.
    `);
    const { Confirm  } = require('enquirer');
    const prompt = new Confirm({
        name: 'question',
        message: `Should we convert the ${validFoundTargetName} target to use the @nrwl/vite:${executor} executor?`,
        initial: true
    });
    const shouldConvert = await prompt.run();
    if (!shouldConvert) {
        throw new Error(`The ${action} target ${userProvidedTargetName} cannot be converted to use the @nrwl/vite:${executor} executor.
      Please try again, either by providing a different ${action} target or by not providing a target at all (Nx will
        convert the first one it finds, most probably this one: ${validFoundTargetName})

      Please note that converting a potentially non-compatible project to use Vite.js may result in unexpected behavior. Always commit
      your changes before converting a project to use Vite.js, and test the converted project thoroughly before deploying it.
      `);
    }
}
async function handleUnknownExecutors(projectName) {
    _devkit.logger.warn(`
      We could not find any targets in project ${projectName} that use executors which 
      can be converted to the @nrwl/vite executors.

      This either means that your project may not have a target 
      for building, serving, or testing at all, or that your targets are 
      using executors that are not known to Nx.
      
      If you still want to convert your project to use the @nrwl/vite executors,
      please make sure to commit your changes before running this generator.
      `);
    const { Confirm  } = require('enquirer');
    const prompt = new Confirm({
        name: 'question',
        message: `Should Nx convert your project to use the @nrwl/vite executors?`,
        initial: true
    });
    const shouldConvert = await prompt.run();
    if (!shouldConvert) {
        throw new Error(`
      Nx could not verify that the executors you are using can be converted to the @nrwl/vite executors.
      Please try again with a different project.
    `);
    }
}
function handleViteConfigFileExists(tree, viteConfigPath, options, buildOption, dtsPlugin, dtsImportLine, pluginOption, testOption, offsetFromRoot, projectAlreadyHasViteTargets) {
    if (projectAlreadyHasViteTargets.build && projectAlreadyHasViteTargets.test) {
        return;
    }
    _devkit.logger.info(`vite.config.ts already exists for project ${options.project}.`);
    const buildOptionObject = {
        lib: {
            entry: 'src/index.ts',
            name: options.project,
            fileName: 'index',
            formats: [
                'es',
                'cjs'
            ]
        },
        rollupOptions: {
            external: [
                options.uiFramework === 'react' ? "'react', 'react-dom', 'react/jsx-runtime'" : ''
            ]
        }
    };
    const testOptionObject = {
        globals: true,
        cache: {
            dir: `${offsetFromRoot}node_modules/.vitest`
        },
        environment: 'jsdom',
        include: [
            'src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'
        ]
    };
    const changed = (0, _viteConfigEditUtils.ensureBuildOptionsInViteConfig)(tree, viteConfigPath, buildOption, buildOptionObject, dtsPlugin, dtsImportLine, pluginOption, testOption, testOptionObject, projectAlreadyHasViteTargets);
    if (!changed) {
        _devkit.logger.warn(`Make sure the following setting exists in your Vite configuration file (${viteConfigPath}):
        
        ${buildOption}
        
        `);
    } else {
        _devkit.logger.info(`
      Vite configuration file (${viteConfigPath}) has been updated with the required settings for the new target(s).
      `);
    }
}

//# sourceMappingURL=generator-utils.js.map