"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpdatedPackageJsonContent = exports.updatePackageJson = void 0;
const devkit_1 = require("@nrwl/devkit");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const path_1 = require("path");
const fileutils_1 = require("nx/src/utils/fileutils");
function getMainFileDirRelativeToProjectRoot(main, projectRoot) {
    const mainFileDir = (0, path_1.dirname)(main);
    const relativeDir = (0, devkit_1.normalizePath)((0, path_1.relative)(projectRoot, mainFileDir));
    return relativeDir === '' ? `./` : `./${relativeDir}/`;
}
function updatePackageJson(options, context, target, dependencies) {
    const pathToPackageJson = (0, path_1.join)(context.root, options.projectRoot, 'package.json');
    const packageJson = (0, fileutils_1.fileExists)(pathToPackageJson)
        ? (0, devkit_1.readJsonFile)(pathToPackageJson)
        : { name: context.projectName };
    if (options.excludeLibsInPackageJson) {
        dependencies = dependencies.filter((dep) => dep.node.type !== 'lib');
    }
    (0, devkit_1.writeJsonFile)(`${options.outputPath}/package.json`, getUpdatedPackageJsonContent(packageJson, options));
    if (dependencies.length > 0 &&
        options.updateBuildableProjectDepsInPackageJson) {
        (0, buildable_libs_utils_1.updateBuildableProjectPackageJsonDependencies)(context.root, context.projectName, context.targetName, context.configurationName, target, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
}
exports.updatePackageJson = updatePackageJson;
function getUpdatedPackageJsonContent(packageJson, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var _o, _p;
    // Default is CJS unless esm is explicitly passed.
    const hasCjsFormat = !options.format || ((_a = options.format) === null || _a === void 0 ? void 0 : _a.includes('cjs'));
    const hasEsmFormat = (_b = options.format) === null || _b === void 0 ? void 0 : _b.includes('esm');
    const mainFile = (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
    const relativeMainFileDir = getMainFileDirRelativeToProjectRoot(options.main, options.projectRoot);
    const typingsFile = `${relativeMainFileDir}${mainFile}.d.ts`;
    const exports = typeof packageJson.exports === 'string'
        ? packageJson.exports
        : Object.assign({ '.': {} }, packageJson.exports);
    const mainJsFile = (_c = options.outputFileName) !== null && _c !== void 0 ? _c : `${relativeMainFileDir}${mainFile}.js`;
    if (hasEsmFormat) {
        // Unofficial field for backwards compat.
        (_d = packageJson.module) !== null && _d !== void 0 ? _d : (packageJson.module = mainJsFile);
        if (!hasCjsFormat) {
            packageJson.type = 'module';
            (_e = packageJson.main) !== null && _e !== void 0 ? _e : (packageJson.main = mainJsFile);
        }
        if (typeof exports !== 'string') {
            if (typeof exports['.'] !== 'string') {
                (_f = (_o = exports['.'])['import']) !== null && _f !== void 0 ? _f : (_o['import'] = mainJsFile);
            }
            else if (!hasCjsFormat) {
                (_g = exports['.']) !== null && _g !== void 0 ? _g : (exports['.'] = mainJsFile);
            }
        }
    }
    // CJS output may have .cjs or .js file extensions.
    // Bundlers like rollup and esbuild supports .cjs for CJS and .js for ESM.
    // Bundlers/Compilers like webpack, tsc, swc do not have different file extensions.
    if (hasCjsFormat) {
        const { dir, name } = (0, path_1.parse)(mainJsFile);
        const cjsMain = `${dir ? dir : '.'}/${name}${(_h = options.outputFileExtensionForCjs) !== null && _h !== void 0 ? _h : '.js'}`;
        (_j = packageJson.main) !== null && _j !== void 0 ? _j : (packageJson.main = cjsMain);
        if (typeof exports !== 'string') {
            if (typeof exports['.'] !== 'string') {
                (_k = (_p = exports['.'])['require']) !== null && _k !== void 0 ? _k : (_p['require'] = cjsMain);
            }
            else if (!hasEsmFormat) {
                (_l = exports['.']) !== null && _l !== void 0 ? _l : (exports['.'] = cjsMain);
            }
        }
    }
    if (options.generateExportsField) {
        packageJson.exports = exports;
    }
    if (!options.skipTypings) {
        packageJson.types = (_m = packageJson.types) !== null && _m !== void 0 ? _m : typingsFile;
    }
    return packageJson;
}
exports.getUpdatedPackageJsonContent = getUpdatedPackageJsonContent;
//# sourceMappingURL=update-package-json.js.map