"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webpackExecutor = void 0;
const tslib_1 = require("tslib");
require("dotenv/config");
const devkit_1 = require("@nrwl/devkit");
const rxjs_for_await_1 = require("@nrwl/devkit/src/utils/rxjs-for-await");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const path_1 = require("path");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const get_webpack_config_1 = require("./lib/get-webpack-config");
const get_emitted_files_1 = require("./lib/get-emitted-files");
const run_webpack_1 = require("./lib/run-webpack");
const fs_1 = require("../../utils/fs");
const write_index_html_1 = require("../../utils/webpack/write-index-html");
const custom_webpack_1 = require("../../utils/webpack/custom-webpack");
const normalize_options_1 = require("./lib/normalize-options");
function getWebpackConfigs(options, context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const metadata = context.projectsConfigurations.projects[context.projectName];
        const projectRoot = metadata.root;
        const isScriptOptimizeOn = typeof options.optimization === 'boolean'
            ? options.optimization
            : options.optimization && options.optimization.scripts
                ? options.optimization.scripts
                : false;
        let customWebpack = null;
        if (options.webpackConfig) {
            customWebpack = (0, custom_webpack_1.resolveCustomWebpackConfig)(options.webpackConfig, options.tsConfig);
            if (typeof customWebpack.then === 'function') {
                customWebpack = yield customWebpack;
            }
        }
        const config = (0, get_webpack_config_1.getWebpackConfig)(context, options);
        if (customWebpack) {
            return yield customWebpack(config, {
                options,
                context,
                configuration: context.configurationName, // backwards compat
            });
        }
        else {
            return config;
        }
    });
}
function webpackExecutor(_options, context) {
    var _a;
    return tslib_1.__asyncGenerator(this, arguments, function* webpackExecutor_1() {
        const metadata = context.projectsConfigurations.projects[context.projectName];
        const sourceRoot = metadata.sourceRoot;
        const options = (0, normalize_options_1.normalizeOptions)(_options, context.root, metadata.root, sourceRoot);
        const isScriptOptimizeOn = typeof options.optimization === 'boolean'
            ? options.optimization
            : options.optimization && options.optimization.scripts
                ? options.optimization.scripts
                : false;
        (_a = process.env).NODE_ENV || (_a.NODE_ENV = isScriptOptimizeOn ? 'production' : 'development');
        if (options.compiler === 'swc') {
            try {
                require.resolve('swc-loader');
                require.resolve('@swc/core');
            }
            catch (_b) {
                devkit_1.logger.error(`Missing SWC dependencies: @swc/core, swc-loader. Make sure you install them first.`);
                return yield tslib_1.__await({
                    success: false,
                    outfile: (0, path_1.resolve)(context.root, options.outputPath, options.outputFileName),
                    options,
                });
            }
        }
        if (!options.buildLibsFromSource && context.targetName) {
            const { dependencies } = (0, buildable_libs_utils_1.calculateProjectDependencies)(context.projectGraph, context.root, context.projectName, context.targetName, context.configurationName);
            options.tsConfig = (0, buildable_libs_utils_1.createTmpTsConfig)(options.tsConfig, context.root, metadata.root, dependencies);
        }
        // Delete output path before bundling
        if (options.deleteOutputPath) {
            (0, fs_1.deleteOutputDir)(context.root, options.outputPath);
        }
        const configs = yield tslib_1.__await(getWebpackConfigs(options, context));
        return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues((0, rxjs_for_await_1.eachValueFrom)((0, rxjs_1.of)(configs).pipe((0, operators_1.switchMap)((config) => {
            return (0, run_webpack_1.runWebpack)(config).pipe((0, operators_1.tap)((stats) => {
                console.info(stats.toString());
            }));
        }), (0, operators_1.switchMap)((result) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const success = result && !result.hasErrors();
            const emittedFiles = (0, get_emitted_files_1.getEmittedFiles)(result);
            if (options.index && options.generateIndexHtml) {
                yield (0, write_index_html_1.writeIndexHtml)({
                    crossOrigin: options.crossOrigin,
                    sri: options.subresourceIntegrity,
                    outputPath: (0, path_1.join)(options.outputPath, (0, path_1.basename)(options.index)),
                    indexPath: (0, path_1.join)(context.root, options.index),
                    files: emittedFiles.filter((x) => x.extension === '.css'),
                    noModuleFiles: [],
                    moduleFiles: emittedFiles,
                    baseHref: options.baseHref,
                    deployUrl: options.deployUrl,
                    scripts: options.scripts,
                    styles: options.styles,
                });
            }
            return {
                success,
                outfile: (0, path_1.resolve)(context.root, options.outputPath, options.outputFileName),
                emittedFiles,
                options,
            };
        }))))))));
    });
}
exports.webpackExecutor = webpackExecutor;
exports.default = webpackExecutor;
//# sourceMappingURL=webpack.impl.js.map